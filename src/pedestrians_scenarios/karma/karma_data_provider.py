import ast
from functools import lru_cache
import logging
import os
from queue import Empty, Queue
from typing import List

import carla
import numpy
from pedestrians_scenarios.karma.utils.deepcopy import deepcopy_location, deepcopy_transform
from pedestrians_scenarios.karma.utils.conversions import convert_list_to_transform
from srunner.scenariomanager.carla_data_provider import CarlaDataProvider

import pandas as pd
import numpy as np


class KarmaDataProvider(CarlaDataProvider):
    """
    ScenarioRunner's CarlaDataProvider with some additional methods exposed.
    """

    _sensors_pool = {}
    _sensors_queue = {}
    _sensors_data = {}
    _sensors_timeout = 1.0

    _pedestrian_spawn_index = 0
    _pedestrian_spawn_points = None

    _available_maps = None

    @staticmethod
    def get_blueprint_library() -> carla.BlueprintLibrary:
        return CarlaDataProvider._blueprint_library

    @staticmethod
    def get_rng(seed=None) -> numpy.random.RandomState:
        if seed is not None:
            CarlaDataProvider._random_seed = seed
            CarlaDataProvider._rng = numpy.random.RandomState(seed)
        return CarlaDataProvider._rng

    @staticmethod
    @lru_cache(maxsize=4)
    def get_pedestrian_blueprints_by_age_and_gender(age: str, gender: str):
        bps = [bp.id for bp in KarmaDataProvider.get_blueprint_library().filter('walker.pedestrian.*')
               if bp.get_attribute('age') == age and bp.get_attribute('gender') == gender]
        logging.getLogger(__name__).debug(
            f'Available {gender} {age} pedestrian blueprints: {bps}')
        return bps

    @staticmethod
    def get_closest_driving_lane_waypoint(location: carla.Transform) -> carla.Waypoint:
        return KarmaDataProvider.get_map().get_waypoint(location)

    @staticmethod
    def get_shifted_driving_lane_waypoint(location: carla.Transform, waypoint_jitter_scale: float = 1.0) -> carla.Waypoint:
        """
        Returns the waypoint shifted by a random distance generated by RandomState.randn.
        """
        road_waypoints = []
        max_lanes = 10  # prevent infinite loop

        lane_waypoint = KarmaDataProvider.get_closest_driving_lane_waypoint(location)
        while max_lanes > 0 and lane_waypoint is not None:
            max_lanes -= 1
            road_waypoints.append(lane_waypoint)
            lane_waypoint = lane_waypoint.get_left_lane()

        random_waypoint = KarmaDataProvider.get_rng().choice(road_waypoints)
        shift = KarmaDataProvider.get_rng().randn() * waypoint_jitter_scale
        shifted_waypoint = random_waypoint
        try:
            # if the distances are too small, the shifted waypoint will be the same as the original (2 cm)
            if shift > 0.02:
                shifted_waypoint = random_waypoint.next(shift)[0]
            elif shift < -0.02:
                shifted_waypoint = random_waypoint.previous(-shift)[0]
        except IndexError:
            pass

        # If the lane goes in the opposite direction, this will 'correct' it,
        # so that the camera is not looking opposite to the traffic.
        # If the lane and waypoint direction match, this will do nothing.
        directed_waypoint = KarmaDataProvider.get_closest_driving_lane_waypoint(
            shifted_waypoint.transform.location)
        return directed_waypoint

    @staticmethod
    def request_new_sensor(blueprint: carla.ActorBlueprint, spawn_point: carla.Transform, tick: bool = True, **kwargs) -> carla.Sensor:
        """
        Spawns a sensor at the given transform and registers its data queue.
        Very similar to CarlaDataProvider.request_new_actor.
        """
        sensor = KarmaDataProvider.get_world().try_spawn_actor(blueprint, spawn_point)

        if sensor is None:
            print('WARNING: Cannot spawn sensor {} at position {}'.format(
                blueprint.id, spawn_point.location))
            return None

        # Wait for the sensor to be spawned properly before we do anything
        if not tick:
            pass
        elif KarmaDataProvider.is_sync_mode():
            KarmaDataProvider.get_world().tick()
        else:
            KarmaDataProvider.get_world().wait_for_tick()

        KarmaDataProvider._sensors_pool[sensor.id] = sensor
        KarmaDataProvider.register_sensor_queue(sensor)

        KarmaDataProvider._carla_actor_pool[sensor.id] = sensor
        KarmaDataProvider.register_actor(sensor)

        return sensor

    @staticmethod
    def register_sensor_queue(sensor):
        if sensor.id not in KarmaDataProvider._sensors_queue:
            KarmaDataProvider._sensors_queue[sensor.id] = Queue()
            sensor.listen(KarmaDataProvider._sensors_queue[sensor.id].put)

    @staticmethod
    def set_world(world):
        CarlaDataProvider.set_world(world)
        logging.getLogger(__name__).debug('CarlaDataProvider.set_world succeeded.')

        # Initialize pedestrian spawn points
        KarmaDataProvider.generate_pedestrian_spawn_points()

    @staticmethod
    def load_spawnpoints_blacklist():

        map_name = os.path.basename(CarlaDataProvider._map.name)
        try:
            spawnpoints_blacklist = pd.read_csv(
                os.path.join(
                    os.path.dirname(__file__),
                    '..',
                    'spawnpoints_blacklist',
                    map_name + '.csv',
                ),
                converters={
                    '0': lambda x: convert_list_to_transform(ast.literal_eval(x))
                }
            )['0'].to_list()
        except:
            logging.getLogger(__name__).debug(
                f'Cannot find spawnpoints blacklist for map {map_name}.')
            return []

        return spawnpoints_blacklist

    @staticmethod
    def filter_pedestrian_spawnpoints(pedestrian_spawn_points):

        spawnpoints_blacklist = KarmaDataProvider.load_spawnpoints_blacklist()

        filtered_spawn_points = []

        for ped_spawnpoint in pedestrian_spawn_points:

            addSpawnpoint = True

            for blacklisted_spawnpoint in spawnpoints_blacklist:
                dist = ped_spawnpoint.location.distance(blacklisted_spawnpoint.location)

                if dist < 15:
                    addSpawnpoint = False
                    break

            if addSpawnpoint:
                filtered_spawn_points.append(ped_spawnpoint)

        return filtered_spawn_points

    @staticmethod
    def generate_pedestrian_spawn_points():
        # for simplicity sake, we generate the same number of spawn points for pedestrians as for vehicles
        pedestrian_spawn_points = [
            carla.Transform(KarmaDataProvider.get_world(
            ).get_random_location_from_navigation())
            for _ in range(len(KarmaDataProvider._spawn_points))
        ]
        pedestrian_spawn_points = KarmaDataProvider.filter_pedestrian_spawnpoints(
            pedestrian_spawn_points)
        if len(pedestrian_spawn_points) == 0:
            raise RuntimeError(
                'All pedestrian spawnpoints have been filtered and pedestrian spawnpoints list is now empty.')
        KarmaDataProvider.get_rng().shuffle(pedestrian_spawn_points)
        KarmaDataProvider._pedestrian_spawn_points = pedestrian_spawn_points
        KarmaDataProvider._pedestrian_spawn_index = 0
        logging.getLogger(__name__).debug(
            f'Generated {len(pedestrian_spawn_points)} pedestrian spawn points.')

    @staticmethod
    def get_pedestrian_spawn_point():
        if KarmaDataProvider._pedestrian_spawn_index >= len(KarmaDataProvider._pedestrian_spawn_points):
            raise RuntimeError('No more pedestrian spawn points to use')
        else:
            spawn_point = KarmaDataProvider._pedestrian_spawn_points[
                KarmaDataProvider._pedestrian_spawn_index]
            KarmaDataProvider._pedestrian_spawn_index += 1

        return deepcopy_transform(spawn_point)

    @staticmethod
    def on_carla_tick(snapshot: carla.WorldSnapshot):
        if not snapshot:
            snapshot = KarmaDataProvider.get_world().get_snapshot()

        world_frame = snapshot.frame

        if world_frame:
            for sensor_id in KarmaDataProvider._sensors_queue.copy():
                frames = []
                sensor_data = None

                # drain the sensor queue
                try:
                    while (sensor_data is None) or sensor_data.frame < world_frame:
                        sensor_data = KarmaDataProvider._sensors_queue[sensor_id].get(
                            True, KarmaDataProvider._sensors_timeout)
                        frames.append(sensor_data)
                except Empty:
                    pass  # no new data
                except KeyError:
                    pass  # sensor has been destroyed

                KarmaDataProvider._sensors_data[sensor_id] = frames

        CarlaDataProvider.on_carla_tick()

    @staticmethod
    def get_sensor_data(sensor_id: int) -> List[carla.SensorData]:
        """
        Returns the sensor data for the given sensor id and current world tick.
        May be empty if no data is available.
        """

        return KarmaDataProvider._sensors_data[sensor_id]

    @staticmethod
    def cleanup():
        # stop all sensors
        for sensor in KarmaDataProvider._sensors_pool.values():
            sensor.stop()

        KarmaDataProvider._sensors_pool = {}
        KarmaDataProvider._sensors_queue = {}
        KarmaDataProvider._sensors_data = {}

        KarmaDataProvider._pedestrian_spawn_points = None
        KarmaDataProvider._pedestrian_spawn_index = 0

        CarlaDataProvider.cleanup()

    @staticmethod
    def get_available_maps():
        """
        Get available map names. Only non-layered maps are returned.
        """
        if not KarmaDataProvider._available_maps:
            KarmaDataProvider._available_maps = [
                map_name
                for map_name in CarlaDataProvider.get_client().get_available_maps()
                if not map_name.endswith('_Opt')
            ]
            logging.getLogger(__name__).debug(
                f'Available maps: {KarmaDataProvider._available_maps}')

        return KarmaDataProvider._available_maps
